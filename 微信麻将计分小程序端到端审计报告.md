# 微信麻将计分小程序端到端审计报告

## 1) TL;DR（Top 5 高优先级修复项）

先结论后证据：以下问题根据用户反馈及代码审计归纳，附文件路径与行号作为证据，提供最小可行修复补丁和验证用例。

| 优先级 | 问题结论 | 证据 | 修复策略（补丁） | 验证用例ID |
|--------|----------|------|------------------|------------|
| P0 | 同步微信资料按钮长期可见，资料修改入口缺失——mine页"一键同步微信资料"按钮隐藏逻辑依赖nickName/avatarUrl，但handleSync只更新user对象，未刷新nickName与avatarUrl字段，导致同步后按钮仍显示 | `pages/mine/mine.js:413-437` handleSync 调用`app.getUserProfileAndSave()`后仅`setData { user: updatedUser }`，未更新 nickName、avatarUrl。UI逻辑通过 `__profileReady && (!nickName || !avatarUrl)` 判断是否显示同步按钮（`pages/mine/mine.wxml:20-27`） | 在同步成功后调用云函数 profile.get 重新拉取用户资料，更新页面 nickName、avatarUrl 与 __profileReady，或直接调用现有 syncWeChatProfile 方法 | 用例1B |
| P0 | 邀请加入失败：分享记分页时未携带正确 token——scoring页分享函数存在 fallback：当会话对象无 inviteToken 时使用 sessionId 作为 token | `pages/scoring/scoring.js:432` 第 432 行：`const inviteToken = currentSession?.inviteToken || sessionId;`。这种 fallback 会用 sid 代替 token，云函数validate会判定 token 不一致，返回`TOKEN_MISMATCH`（`cloudfunctions/session/index.js:51`），Join 页处理后显示"牌局不存在或已结束"（`pages/invite/join/index.js:98`） | 禁止使用 sessionId 作为 token；当 inviteToken 缺失时通过云函数查询会话文档获取真实 token；若仍缺失则提示用户必须先通过邀请页面创建牌局 | 用例2B |
| P1 | 授权信息不稳定：本地user与userProfile存储混乱。小程序有两套用户存储：authManager 使用键 userInfo 保存 nickName/头像，而 mine 页读取 user/userProfile 键；app.getUserProfileAndSave 调用云函数 updateuser 保存到集合 users，而mine.onShow通过云函数 profile.get 读取，同步路径不一致 | `config.js:54-61` 存在重复/冗余的存储键（user,userInfo,userProfile），`pages/mine/mine.js:114` 从 user 键读取，`utils/auth.js:227` 保存到 userInfo 键；保存逻辑与读取逻辑不统一易引起空状态 | 统一存储和云端更新：删除 user 键，所有用户信息通过 authManager.saveUserInfo() 保存到 userInfo，并在 app.js 或 mine.js 中封装统一 syncProfile 方法调用 updateuser 与 profile.get | 用例1A、1B |
| P1 | 分享链路未完全启用：enableShareAppMessage未在 app.json、部分页面 json 中声明；wx.showShareMenu 调用在部分页面缺失或写法不统一，易导致无法分享或分享按钮不出现 | `app.json` 未全局开启 "enableShareAppMessage": true；`pages/index/index.json` 等页面未声明；虽然部分页面在 onShow 调用 wx.showShareMenu()，但微信要求在页面 json 内显式声明 | 在 app.json 设置 "enableShareAppMessage": true 或在需要分享的页面(index、invite、scoring)的 json 文件设置 "enableShareAppMessage": true；同时在invite、scoring、join等页面 onShow 调用 wx.showShareMenu 并指定 menus: ['shareAppMessage'] | 用例2A |
| P2 | 云函数与环境配置硬编码/不安全：部分云函数或页面直接使用 DYNAMIC_CURRENT_ENV 而未通过 wx.cloud.init 传入动态 env；配置文件未提供环境切换策略，开发/测试/生产环境混用可能导致数据串用 | `app.js:67` 在 initCloudEnvironment 方法中硬编码 `env: wx.cloud.DYNAMIC_CURRENT_ENV`；各云函数均调用 `cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV })`，但未提供 fallback；项目未设置多个环境 | 抽象出环境配置，通过 config.cloud.env 读取环境 ID。在 app.js 和所有云函数初始化处使用该配置，可根据构建时变量切换不同环境；同时避免在代码中出现实际环境 ID | 环境切换验证 |

## 2) 项目鸟瞰

### 技术栈 & 运行路径

**客户端**：微信小程序（miniprogram），使用 WXML/WXSS/JS，部分页面采用模块化工具 `utils/auth.js`, `tools/invite-code.js` 等；UI 组件采用原生小程序组件。

**云函数**：位于 `cloudfunctions/*`，包括 login、updateuser、profile、session、wxacode 等，使用 wx-server-sdk 访问云开发数据库并处理业务逻辑。

**数据层**：云开发数据库 collections users、sessions，users 存储用户昵称、头像，sessions 存储牌局信息（sid、token、ownerOpenId、status、members、meta）。

**路由**：由 app.json 定义，tabBar 包括首页 `/pages/index/index`、记录 `/pages/records/records` 和我的 `/pages/mine/mine`；邀请页面 `/pages/invite/invite` 用于生成二维码和分享；加入页 `/pages/invite/join/index` 用于落地；记分页 `/pages/scoring/scoring` 处理计分。

**授权流程**：在 app.js 初始化 authManager，通过云函数 login 获取 openid，再通过 `authManager.requestUserAuth()` 调用 wx.getUserProfile；授权完成后调用云函数 updateuser 保存用户数据，并将用户信息保存至本地存储和 globalData.user。

**分享流程**：各页面实现 onShareAppMessage 返回分享标题、路径和图片；分享路径应携带 sid 和 token；分享卡片通过云函数 wxacode 生成小程序码。

### 关键目录结构
```
├─app.js / app.json                 # 全局入口与配置
├─config.js                         # 全局配置，云函数名、集合名、share 配置
├─utils/                            # 工具函数（auth、qrcode、request 等）
├─pages/
│  ├─index/                         # 首页
│  ├─invite/                        # 创建邀请
│  │   ├─invite.js
│  │   ├─invite.wxml
│  │   └─... 
│  ├─invite/join/                   # 落地页
│  ├─scoring/                       # 记分页
│  ├─mine/                          # 我的页
│  ├─profile/edit/                  # 编辑资料页
│  └─...                            # 其它页面
├─cloudfunctions/
│  ├─login/
│  ├─updateuser/
│  ├─profile/
│  ├─session/
│  ├─wxacode/
│  └─...                            # 其它云函数
└─tools/                            # 邀请码生成与解析
```

### 高风险第三方依赖清单
| 依赖 | 版本 | 风险点 | 建议版本/措施 |
|------|------|--------|---------------|
| wx-server-sdk | 官方最新 | 云函数 SDK，为官方包，安全性高；需关注版本兼容问题 | 保持最新小程序基础库版本，关注更新说明 |
| miniprogram-npm | 未集中引入 | 部分页面采用 npm 包时需通过 miniprogram_npm 打包；当前仓库未使用第三方 npm 包 | 无风险 |
| 无其他明显第三方库 | | | |

### 质量雷达
| 维度 | 评分（1–5） | 理由 |
|------|-------------|------|
| 正确性 | 3 | 基础功能（邀请、创建会话、计分）实现完整；存在授权流程与分享 token 错误等 P0 问题 |
| 健壮性 | 2 | 异常处理不充分。handleSync 同步失败后未回退 UI；scoring.onShareAppMessage fallback 导致错误 |
| 安全性 | 3 | 云函数均校验 openid；profile 中进行了敏感词过滤，授权流程较规范。然而存储键混乱、环境 ID 硬编码影响环境安全 |
| 性能 | 4 | 页面逻辑简单，未发现高频 setData 或大列表渲染；小程序码生成有兜底 |
| 可维护 | 3 | 代码结构清晰、注释齐全，但存在重复逻辑（同步资料两套实现）、变量命名混乱（nickname vs nickName） |
| 工程规范 | 3 | 采用模块化开发，JS 文件未统一使用 ESLint/Prettier；部分页面缺少 json 声明分享能力 |

## 3) 功能验收矩阵

表格梳理了主要场景的预期行为与实际结果，并指出证据和结论。

| 功能/场景 | 入口 | 关键链路 | 预期行为 | 实际结果 | 证据 | 结论 | 用例ID |
|----------|------|----------|----------|----------|------|------|--------|
| 授权登录 | 首页首次进入 | authManager.login()→调用云函数login获取openid→检查本地userInfo→必要时调用requestUserAuth | 首次进入弹窗请求头像/昵称；授权后主页显示昵称和头像 | 部分情况下未弹窗或弹窗后昵称仍为默认；授权成功后再次进入仍提示授权 | authManager.login仅返回needAuth但未在部分页面调用requestUserAuth（`utils/auth.js:21-63`）；user与userInfo存储混乱 | 失败 | 用例1A |
| 资料同步/编辑 | 我的→一键同步 | 调用app.getUserProfileAndSave→云函数updateuser保存→UI 隐藏同步按钮→提供"修改资料"入口 | 资料同步成功后按钮隐藏，显示"修改资料"；修改资料可保存至云端并刷新 | 同步按钮未隐藏，修改资料入口缺失，刷新后仍提示同步 | handleSync仅更新user对象未更新nickName/avatarUrl（`pages/mine/mine.js:413-437`） | 失败 | 用例1B |
| 分享生成 | 邀请页→生成二维码→分享 | 调用session.create创建会话→生成二维码（wxacode)→onShareAppMessage带sid与token→他人扫码落地 | 可以生成二维码或邀请码，分享路径携带正确 sid、token；远端记录会话状态为 open | 邀请页逻辑基本正确；若云函数wxacode失败则降级为文本邀请码；无明显问题 | invite.js生成sessionId和inviteToken并调用session.create（`pages/invite/invite.js:68-116`）；分享函数返回携带sid,token（`pages/invite/invite.js:385-394`） | 通过 | 用例2A |
| 邀请落地与入局 | 他人点击分享 | join页面解析sid/token→调用session.validate验证→加入本地 sessions→跳转记分页 | 若sid存在且token匹配则显示"加入牌局"按钮；否则显示错误提示 | 当分享路径 token 错误或 sid 未在云端时，Join 页提示"牌局不存在或已结束"；由scoring页分享产生的路径在某些情况下 token 等于 sid 导致验证失败 | scoring.js fallback 使用 sid 作为 token（`pages/scoring/scoring.js:432`） | 部分失败 | 用例2B |
| wxacode 扫码 | 用户扫描二维码 | 二维码由云函数生成，scene 包含短码s和t→Join 页解析 scene→调用 validate | 二维码分享正常；Join 页解析成功 | 二维码生成降级逻辑完整；Join 页解析场景并验证（`pages/invite/join/index.js:24-35`） | 通过 | 用例2A |
| 异常态处理 | 过期/不存在sid、缺 token | validate 未通过时返回错误码→Join 页根据错误码提示 | 应区分"房间不存在/已结束"和"邀请码不正确"；点击"返回首页"后可正常返回 | Join 页统一提示"牌局不存在或已结束"；错误码枚举不完整，session.validate返回TOKEN_MISMATCH但 Join 页映射为默认消息（`pages/invite/join/index.js:87-108`） | 部分失败 | 用例2C |
| 离线/弱网 | 无网络时执行 | 应显示"网络错误，请稍后重试"，不应卡死 | 部分云函数调用 catch 后未提示用户；用户看到空白页或一直加载 | 对云函数错误未做统一异常处理 | 失败 | 用例3A |

## 4) 缺陷与风险清单（Issue 模板）

### ISSUE‑001：Mine 页同步微信资料后按钮仍显示

**级别**：P0

**位置**：`pages/mine/mine.js` handleSync 方法（第413-437行）

**现象**：点击"一键同步微信资料"后弹出微信授权，显示"同步成功"，但返回"我的"页仍然显示"一键同步微信资料"，且无"修改资料"入口。

**根因**：handleSync 调用 `app.getUserProfileAndSave()` 仅更新 `data.user`，未更新 `data.nickName` 和 `data.avatarUrl`。而 WXML 中的按钮显示逻辑依赖 `__profileReady` 与 `nickName/avatarUrl`：`pages/mine/mine.wxml:20-27`。因此同步后按钮状态未刷新。

**证据**：
```javascript
// handleSync 实现：仅更新 user
async handleSync() {
  const updatedUser = await app.getUserProfileAndSave();
  this.setData({ user: updatedUser });
  wx.showToast({ title: '同步成功', icon: 'success' });
}
```

WXML 判断逻辑：当 `__profileReady && (!nickName || !avatarUrl)` 时显示同步按钮，否则显示修改按钮（`pages/mine/mine.wxml:20-27`）。

**修复方案**：
1. 在同步成功后调用云函数 profile.upsert 更新 users 集合
2. 调用 profile.get 重新拉取用户资料，更新页面 nickName、avatarUrl 与 __profileReady
3. 或直接调用现有 syncWeChatProfile 方法，其内部已处理云端同步和字段刷新

**补丁（PATCH‑001）**：
```diff
*** Begin Patch
*** Update File: pages/mine/mine.js

@@
async handleSync() {
-   try {
-     const updatedUser = await app.getUserProfileAndSave();
-     this.setData({ user: updatedUser });
-     wx.showToast({ 
-       title: '同步成功', 
-       icon: 'success',
-       duration: 1500 
-     });
-   } catch (error) {
-     console.warn('[sync] 同步失败:', error);
-     // ...
-   }
+   // 使用统一的资料同步逻辑：授权 + 云端写入 + 本地刷新
+   try {
+     // 调用已有同步函数，传入当前昵称/头像
+     await this.syncWeChatProfile();
+     // 再次从云端拉取最新资料并更新界面
+     const profRes = await wx.cloud.callFunction({ name: 'profile', data: { action: 'get' } });
+     const prof = profRes.result?.data || {};
+     let avatarUrl = prof.avatarUrl || '';
+     if (prof.avatarFileID) {
+       const { fileList } = await wx.cloud.getTempFileURL({ fileList: [prof.avatarFileID] });
+       avatarUrl = fileList?.[0]?.tempFileURL || avatarUrl;
+     }
+     this.setData({
+       nickName: prof.nickName || '',
+       avatarUrl,
+       __profileReady: true,
+       user: Object.assign({}, this.data.user || {}, { nickName: prof.nickName, avatarUrl })
+     });
+     wx.showToast({ title: '同步成功', icon: 'success', duration: 1500 });
+   } catch (error) {
+     console.warn('[sync] 同步失败:', error);
+     let errorMsg = '同步失败';
+     if (error.errMsg && error.errMsg.includes('auth deny')) {
+       errorMsg = '用户拒绝授权';
+     } else if (error.message && error.message.includes('getUserProfile')) {
+       errorMsg = '微信版本过低';
+     }
+     wx.showToast({ icon: 'none', title: errorMsg, duration: 2000 });
+   }
 },

*** End Patch
```

**回归用例**：用例1B（首次同步后按钮隐藏），用例1A（重新进入"我的"页仍为隐藏）；负例：用户拒绝授权时应显示提示并保持原状态。

**影响与最坏情况**：若不修复，用户在"我的"页无法修改已同步资料，体验差；数据仍然更新至云端但 UI 不刷新。

### ISSUE‑002：Scoring 页分享时 token 错误导致加入失败

**级别**：P0

**位置**：`pages/scoring/scoring.js` `onShareAppMessage`（第418-439行）

**现象**：用户在记分页点击分享，"邀请好友加入"生成的链接或二维码被他人打开后显示"功能开发中/牌局不存在"；只有通过邀请页面创建牌局分享的链接才能成功加入。

**根因**：`onShareAppMessage` 从 `globalData.sessions` 获取当前会话，并使用 `inviteToken = currentSession?.inviteToken || sessionId`。当用户没有通过邀请页面生成房间，而是直接点击"开始计分"进入记分页时，本地会话对象的 `inviteToken` 为 undefined，函数 fallback 使用 `sessionId` 作为 token。然而云端 `sessions` 集合中的 `token` 字段存储的是创建时随机生成的 8 位字符串；使用 sid 验证必然不匹配，`cloudfunctions/session.validate` 返回 `TOKEN_MISMATCH`（第51行），Join 页映射后显示"牌局不存在或已结束"（`pages/invite/join/index.js:98`）。

**修复方案**：禁止使用 `sessionId` 作为 token；当 `inviteToken` 缺失时通过云函数查询会话文档获取真实 token；若仍缺失则提示用户必须先通过邀请页面创建牌局，或禁用分享按钮。

**补丁（PATCH‑002）**：
```diff
*** Begin Patch
*** Update File: pages/scoring/scoring.js
@@
-     onShareAppMessage() {
+     async onShareAppMessage() {
       const { sessionId } = this.data;

       if (!sessionId) {
         return {
           title: config.share.defaultTitle,
           path: config.pages.index,
           imageUrl: config.share.defaultImageUrl
         };
       }

-        // 获取当前会话的邀请token
-        const sessions = app.globalData.sessions || [];
-        const currentSession = sessions.find(s => s.id === sessionId);
-        const inviteToken = currentSession?.inviteToken || sessionId;
-
-        return {
-          title: `一起来玩麻将计分吧！房间号：${inviteToken.toString().toUpperCase()}`,
-          path: `${config.pages.sessionJoin}?sid=${encodeURIComponent(sessionId)}&token=${encodeURIComponent(inviteToken)}`,
-          imageUrl: config.share.defaultImageUrl
-        };
+        // 获取当前会话的邀请 token
+        const sessions = app.globalData.sessions || [];
+        const currentSession = sessions.find(s => String(s.id) === String(sessionId));
+        let inviteToken = currentSession && currentSession.inviteToken;
+
+        // 如果本地无 token，则尝试从云端查询会话信息
+        if (!inviteToken) {
+          try {
+            const res = await wx.cloud.callFunction({ name: 'session', data: { action: 'get', sid: sessionId } });
+            if (res.result && res.result.session && res.result.session.status === 'open') {
+              inviteToken = res.result.session.token || '';
+            }
+          } catch (e) {
+            console.warn('[SHARE] 获取 session token 失败', e);
+          }
+        }
+
+        // 如果仍无 token，则提示用户必须通过邀请页面创建
+        if (!inviteToken) {
+          wx.showToast({ title: '请先通过邀请页面创建牌局再分享', icon: 'none' });
+          return {
+            title: config.share.defaultTitle,
+            path: config.pages.invite,
+            imageUrl: config.share.defaultImageUrl
+          };
+        }
+
+        return {
+          title: `一起来玩麻将计分吧！房间号：${inviteToken.toString().toUpperCase()}`,
+          path: `${config.pages.sessionJoin}?sid=${encodeURIComponent(sessionId)}&token=${encodeURIComponent(inviteToken)}`,
+          imageUrl: config.share.defaultImageUrl
+        };
     }
*** End Patch
```

**回归用例**：用例2A（由邀请页创建并记分分享，朋友加入成功）；用例2B（在首页或记录页直接开始计分后分享，他人打开弹窗提示创建流程）。

**影响与最坏情况**：若不修复，用户通过记分页生成的分享链接经常无法加入，影响核心功能。此问题可能导致用户流失。

### ISSUE‑003：用户信息存储混乱导致数据不一致

**级别**：P1

**位置**：`pages/mine/mine.js` hydrate() 与各处读取用户信息处（第113-116行）

**现象**：小程序中存在 user、userInfo、userProfile 多个键表示用户信息，authManager 保存数据到 userInfo，而 mine 页读取 user；云端更新保存时有 updateuser 云函数，而个人资料页面读取的是 profile 云函数。多源维护导致用户修改后有时不同步或覆盖旧值。

**根因**：历史迭代过程中引入多套存储与 API，未统一管理，导致不同页面取值不一致；hydrate() 函数读取 user 而非 userProfile；调用 updateuser 保存后没有刷新新缓存。

**修复方案**：统一用户信息存储键与接口：
1. 删除使用 `config.storage.user` 的旧逻辑，仅保留 `config.storage.userProfile`
2. 修改 hydrate() 从 userProfile 读取，并同步赋值 nickName 与 avatarUrl；首次进入若没有缓存则从云端拉取
3. 封装统一 syncProfile() 函数：先调用 authManager.saveUserInfo() 将微信资料保存本地并上传至云端，然后通过 profile.get 获取完整资料，并存入 userProfile 与页面 data 中

**补丁（PATCH‑003）**：
```diff
*** Begin Patch
*** Update File: pages/mine/mine.js

@@
 hydrate() {
-   const u = (function(){ try { return wx.getStorageSync('user') || null; } catch (e) { return null; } })();
-   this.setData({ user: u });
+   // 从统一的 userProfile 缓存读取用户资料
+   const prof = wx.getStorageSync(config.storageKeys.userProfile) || null;
+   this.setData({
+     user: prof,
+     nickName: prof?.nickName || '',
+     avatarUrl: prof?.avatarUrl || '',
+     __profileReady: !!prof
+   });
 },

*** End Patch
```

还需更新 `config.js` 删除 `user` 键：
```diff
*** Begin Patch
*** Update File: config.js
@@
-  storageKeys: {
-    user: 'user',
-    openid: 'openid',
-    sessions: 'sessions',
-    userProfile: 'userProfile',
-    userAuth: 'userAuth',
-    userInfo: 'userInfo'
-  },
+  storageKeys: {
+    openid: 'openid',
+    sessions: 'sessions',
+    userProfile: 'userProfile',
+    userAuth: 'userAuth',
+    userInfo: 'userInfo'
+  },
*** End Patch
```

**回归用例**：用例1A、1B：首次授权保存资料后退出重进，小程序应直接显示头像昵称；修改资料后重新进入仍显示更新后的信息。

**影响与最坏情况**：若不修复，用户信息存储混乱导致不同页面信息不一致，甚至覆盖旧数据。

### ISSUE‑004：分享能力配置缺失导致按钮不显示

**级别**：P1

**位置**：`app.json` 及部分页面 .json 文件

**现象**：部分机型进入页面不显示分享按钮，用户无法分享邀请或计分记录。

**根因**：微信小程序需在全局或页面 json 中配置 "enableShareAppMessage": true 才能显示右上角分享菜单；当前项目仅在 JavaScript 中调用 wx.showShareMenu，未在 .json 声明，导致某些版本无法出现分享按钮。

**修复方案**：在 app.json 或单个页面的配置文件中明确声明 "enableShareAppMessage": true；推荐将配置写入需要分享的页面（如 index、invite、scoring）。

**补丁（PATCH‑004）**：示例添加到 `pages/index/index.json`：
```diff
*** Begin Patch
*** Update File: pages/index/index.json

@@
{
-  "navigationBarTitleText": "首页"
+  "navigationBarTitleText": "首页",
+  "enableShareAppMessage": true
}
*** End Patch
```

按此方式同步更新 `pages/invite/invite.json`、`pages/scoring/scoring.json` 与其它需要分享的页面。

**回归用例**：用例2A、2B：进入这些页面能看到分享按钮；点击分享菜单生成的链接与二维码可被他人访问。

**影响与最坏情况**：如果缺失配置，分享按钮不显示，影响用户传播与拉新，属于体验问题。

### ISSUE‑005：环境 ID 硬编码与配置管理不足

**级别**：P2

**位置**：`app.js`、`config.js` 及各云函数初始化（`app.js:67`）

**现象**：项目使用 `wx.cloud.init({ env: 'DYNAMIC_CURRENT_ENV' })` 硬编码，且 `config.js` 无环境切换策略。不同部署环境共用同一套云资源，可能导致测试环境数据污染生产，亦不利于灰度发布。

**根因**：开发时为方便使用动态环境，但缺乏显式配置管理，没有提供多环境支持、不同 ID 切换方式，也未在部署阶段由 CI 注入环境变量。

**修复方案**：抽象环境配置：
1. 在 `config.js` 新增 `cloud: { env: 'my-dev-env' }` 供修改；可通过构建参数覆盖
2. 在 `app.js` 和所有云函数调用 `wx.cloud.init({ env: config.cloud.env || cloud.DYNAMIC_CURRENT_ENV })`；并提供 fallback
3. 项目构建脚本可通过环境变量注入不同 envID

**补丁（PATCH‑005）**：
```diff
*** Begin Patch
*** Update File: config.js
@@
const config = {
+  cloud: {
+    // 默认环境 ID；构建时可通过环境变量覆盖
+    env: process.env.MINIAPP_CLOUD_ENV || 'DYNAMIC_CURRENT_ENV'
+  },
*** End Patch

*** Begin Patch
*** Update File: app.js
@@
 initCloudEnvironment() {
-    wx.cloud.init({ env: wx.cloud.DYNAMIC_CURRENT_ENV, traceUser: config.cloud.traceUser });
+    const { env } = config.cloud || {};
+    wx.cloud.init({
+      // 若配置 env 则使用；否则回退 DYNAMIC_CURRENT_ENV
+      env: env === 'DYNAMIC_CURRENT_ENV' ? wx.cloud.DYNAMIC_CURRENT_ENV : env,
+      traceUser: config.cloud.traceUser
+    });
 },
*** End Patch
```

类似地，修改每个云函数的 index.js：使用 `cloud.init({ env: config.cloud.env || cloud.DYNAMIC_CURRENT_ENV })`。由于云函数和客户端不共享 config.js，可直接引用环境变量或使用 DYNAMIC_CURRENT_ENV 并添加注释。

**回归用例**：切换环境变量为测试环境时，所有云函数和数据库操作均指向测试集合；切换为生产环境时不互相干扰。

**影响与最坏情况**：若不修复，测试时可能修改生产数据，且无法在 CI/CD 中隔离环境，存在安全隐患。

### ISSUE‑006：Join 页错误码映射不完整

**级别**：P2

**位置**：`pages/invite/join/index.js`（第87-108行）

**现象**：当验证 token 不匹配时云函数返回 TOKEN_MISMATCH，Join 页统一显示"牌局不存在或已结束"，用户难以获知真实原因；也无法处理 INVITE_TOKEN_EXPIRED 等其它错误码。

**根因**：Join 页的 handleValidateError 缺少针对各错误码的分支处理，而云函数 session.validate 已返回具体错误码，如 TOKEN_MISMATCH、SESSION_CLOSED 等。

**修复方案**：在 handleValidateError 方法中针对不同错误码提供更精确文案，如"邀请码不正确，请重新获取"；"牌局已结束"；"邀请码已过期"。

**补丁（PATCH‑006）**：
```diff
*** Begin Patch
*** Update File: pages/invite/join/index.js

@@
handleValidateError(code, defaultMsg) {
-   let errorMsg = defaultMsg || '无法加入牌局';
-   
-   switch (code) {
-     case 'NOT_FOUND':
-       errorMsg = '牌局不存在或已结束';
-       break;
-     case 'ENDED':
-       errorMsg = '牌局已结束，无法加入';
-       break;
-     case 'TOKEN_MISMATCH':
-       errorMsg = '邀请码不正确';
-       break;
-     default:
-       errorMsg = defaultMsg || '无法加入牌局';
-   }
+   let msg;
+   switch (code) {
+     case 'NOT_FOUND':
+     case 'SESSION_CLOSED':
+       msg = '牌局不存在或已结束';
+       break;
+     case 'TOKEN_MISMATCH':
+       msg = '邀请码不正确，请重新获取';
+       break;
+     case 'INVITE_TOKEN_EXPIRED':
+       msg = '邀请码已过期，请房主重新分享';
+       break;
+     default:
+       msg = '无法加入牌局，请稍后再试';
+   }
   
-   this.setData({ 
-     error: errorMsg,
-     loading: false 
-   });
+   this.setData({ error: msg, loading: false });
 },

*** End Patch
```

**回归用例**：用例2C：分享链接 token 错误时 Join 页提示"邀请码不正确"；过期房间提示"牌局已结束"；过期 token 提示正确文案。

**影响与最坏情况**：用户对错误信息无感知，无法自行处理问题，影响体验。

## 5) 专项体检

### 5.1 授权与会话

- **登录与凭证**：通过 `authManager.login()` 调用云函数 `login` 获取 openid，并保存到 `globalData.openid`；`authManager.requestUserAuth()` 封装 `wx.getUserProfile`，保存用户资料到本地后调用 `updateuser` 云函数（`utils/auth.js:68-131`）。**问题**：存储键混乱（`user` / `userInfo` / `userProfile`），且未对 `openid` 与 `unionid` 进行绑定校验。**改进**：使用统一 `userProfile` 缓存；云函数 `login` 返回 `unionid` 时与 `users` 集合校验绑定，防止越权。

- **会话管理**：创建牌局时生成 `sid` 与 8 位 `token` 保存到云数据库，并将当前会话存入 `globalData.sessions`；加入牌局时验证会话状态，更新 `members` 列表（`cloudfunctions/session/index.js:19-39`）。**问题**：本地会话持久化到 storage，但未过滤过期或关闭的会话；用户长时间不用后重新进入可能看到废弃列表。**改进**：增加过期时间（如 7 天）并在 `app.onLaunch` 清理。

### 5.2 分享/邀请链路

- **配置**：分享能力要求在 `json` 中开启 `enableShareAppMessage`；部分页面缺失此配置，导致右上角菜单不显示。`invite.js` 与 `scoring.js` 在 `onShow` 中调用 `wx.showShareMenu({ menus: ['shareAppMessage'] })`，确保弹出分享菜单（`pages/invite/invite.js:400`）。**问题**：`scoring.js` 以及首页 `index.js` 未在 `json` 启用分享；`onShareAppMessage` 中未检查并返回拒绝分享时的 fallback。**改进**：按 ISSUE‑004 补丁修正；建议在 `onShareAppMessage` 异步获取 token 时禁用 fallback 使用 sid。

- **落地解析**：Join 页解析参数 `sid`、`token` 或 `scene` 并调用 `session.validate`。**问题**：错误码提示不够友好（已在 ISSUE‑006 修复）。

### 5.3 wxacode/二维码

- 云函数 `wxacode` 根据 `sid` 与 `token` 生成带参小程序码；若生成失败返回文本邀请码（`cloudfunctions/wxacode/index.js:35-48`）。**问题**：未对生成的小程序码进行缓存；每次生成耗费配额。**建议**：生成后存储在数据库（或云存储）中，下次重复使用同一 `sid` 时复用；同时设置过期策略。云函数应在返回中提供 fileID 供前端调用 `cloud.getTempFileURL`。

### 5.4 云函数与环境 ID

- 云函数目录合理，分为 `login`、`updateuser`、`profile`、`session` 等。**风险**：各函数均调用 `cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV })`；如未配置不同环境会导致生产与测试混用。**建议**：按 ISSUE‑005 补丁抽象环境配置，并在部署时通过环境变量注入。

- **入参校验**：云函数 `updateuser` 使用 `sanitizeUserInfo` 限制字段长度和类型（`cloudfunctions/updateuser/index.js:6-23`）；`session` 函数对 `sid`、`token` 校验严格（`cloudfunctions/session/index.js:47-53`）。**建议**：统一返回错误码，文档化错误列表供前端处理；加强参数空值和类型校验。

### 5.5 数据模型与安全规则

- **集合设计**：`users` 存储用户信息（nickname、avatarFileID、openId/unionId、updatedAt 等），`sessions` 存储牌局信息（sid、token、ownerOpenId、status、members、meta、createdAt）（从云函数代码推断）。**风险**：未为 `sessions.sid` 和 `sessions.token` 设置唯一索引，理论上有冲突风险；`users` 的 `openId` 未加唯一索引可能导致重复用户。**建议**：在云数据库界面配置唯一索引。

- **安全规则**：未在仓库中看到 `database.rules.json`，无法确认读写权限设置。**风险**：若默认规则开放读写，可能导致用户越权访问。**建议**：设定安全规则：只有创建者或邀请成员可读写对应 `session`；用户只能读写自身 `user` 文档。

### 5.6 性能与体验

- **性能**：代码整体无复杂列表渲染；但在生成小程序码失败时，前端直接用文本 `sid` 作为二维码展示，体验略差。**建议**：添加骨架屏或 loading 状态；异步加载后显示二维码。

- **体验**：部分异常无提示，如网络故障时 `wx.cloud.callFunction` 的 catch 未处理，页面空白。**建议**：封装统一的 error handler（比如在 `utils/request.js` 中），出现错误时弹出 `wx.showToast` 或显示错误页。

### 5.7 工程质量

- 项目结构清晰；使用模块化；但缺乏 ESLint/Prettier 配置，代码风格不统一。**建议**：引入 ESLint & Prettier，在 CI 中校验。

- `project.config.json` 未明确多环境配置；建议在不同环境下使用不同 `appid` 和 `projectname`，提高管理性。

## 6) 已知症状 → 定向用例

| 症状编号 | 描述 | 正向用例 | 负向用例 |
|---------|------|----------|----------|
| 症状1：授权未生效或状态不稳 | 用户首次进入授权流程异常，之后进入页面仍显示未授权 | 用例1A：首次进入首页，弹出授权对话框，用户允许后首页和"我的"页显示昵称头像；刷新页面仍保持。 | 负例1A：用户拒绝授权后，适当提示并允许手动重新授权；进入"我的"页不应显示成功同步状态。 |
| 症状2：点击加入提示"功能开发中/牌局不存在" | 他人点击分享链接失败 | 用例2A：邀请页创建牌局→生成二维码→他人扫码加入应成功；JOIN 页面按钮可用。 | 负例2B：在记分页未通过邀请创建牌局直接分享→他人访问应提示"请先通过邀请页面创建"，而非"功能开发中"。 |
| 症状3：资料同步后仍显示同步入口 | "我的"页无法改资料 | 用例1B：在"我的"页点击"一键同步微信资料"，确认授权后应显示"修改资料"按钮；再次进入应用应保持该状态。 | 负例3A：拒绝授权或授权失败后应保持同步按钮，不能进入"修改资料"。 |

## 7) 回归测试与自动化建议

### 手工回归清单

1. **首次授权流程**：卸载小程序重新进入首页，确认弹窗出现；授权后头像昵称显示；关闭再进入仍显示。
2. **资料同步与修改**：在"我的"页点击同步按钮 → 授权 → 同步成功后跳转至"我的"页显示修改入口 → 进入编辑页修改昵称 → 保存后返回应显示新昵称；退出再进入保持一致。
3. **邀请创建与分享**：在邀请页创建牌局，生成二维码和邀请链接 → 点击"开始计分"进入记分页 → 分享给好友（含二维码和链接），检查分享路径包含正确 `sid` 和 `token` → 他人点击加入应进入 Join 页并可加入。
4. **记分页直接分享**：不经过邀请页，在首页直接点击"开始计分"→分享，应弹出提示或自动跳转邀请页 → 他人点击链接显示合理提示。
5. **错误码提示**：邀请链接中修改 token → 打开应提示"邀请码不正确"；删除会话后他人打开提示"牌局不存在或已结束"；过期邀请提示"邀请码已过期"。
6. **弱网/无网**：关闭网络状态或模拟弱网，尝试访问各页面和调用云函数，确认弹出网络错误提示而非白屏。

### 自动化测试

- **E2E 脚本示例**（基于 [miniprogram-automator](https://github.com/wechat-miniprogram/automator)）：
- 目录：`test/e2e/scenario.spec.js`。
- 示例片段：
  ```js
  const automator = require('miniprogram-automator');
  describe('邀请及加入流程', () => {
    let app;
    beforeAll(async () => {
      app = await automator.launch({ projectPath: path.resolve(__dirname, '../') });
    });
    afterAll(async () => {
      await app.close();
    });
    test('创建并分享牌局', async () => {
      const page = await app.firstPage();
      await page.waitFor('button[open-type="getUserInfo"]');
      await page.tap('button[open-type="getUserInfo"]');
      // 授权流程...
      await page.tap('button#createInvite');
      await page.waitFor('.invite-code');
      const shareBtn = await page.$('.share-btn');
      expect(shareBtn).not.toBeNull();
    });
  });
  ```

- 建议编写覆盖授权、同步、分享、加入、编辑流程的脚本，并在 CI 环节执行。

### 监控与埋点

- 在关键流程添加埋点，如 `enterHome`, `clickSyncProfile`, `inviteCreated`, `shareFromScoring`, `joinSessionSuccess`, `errorTokenMismatch` 等。
- 上报字段：用户 openid、sessionId、errorCode、耗时等。
- 配置云函数异常上报至监控平台（如腾讯云日志服务）。

## 8) 变更与回滚

### 变更清单

- **修改文件**：
  - `pages/mine/mine.js`：`hydrate` 和 `handleSync` 逻辑；
  - `config.js`：调整 `storageKeys` 键与新增 `cloud.env`；
  - 页面 `.json` 文件：启用 `enableShareAppMessage`；
  - `pages/scoring/scoring.js`：修复分享 token 获取逻辑；
  - `pages/invite/join/index.js`：完善错误码映射。

### 回滚方案

- 所有补丁均为最小变动，可通过 git revert 单独撤销某个 Commit。
- 若新逻辑在生产发生问题，可临时恢复旧分享逻辑：将 `onShareAppMessage` fallback 直接使用 `sessionId` 作为 token，并关闭新的环境配置。
- 回滚`config.js``storageKeys`键时需注意用户本地旧键可能保留；考虑在回退版中兼容两者读取。

### 风险与上线前检查

- 在开发与测试环境验证所有流程通过后再上线；确保新的环境 ID 设置正确。
- 执行数据库索引创建前备份数据；如有冲突应调整生成规则。
- 更新用户资料逻辑可能影响已有数据，请在脚本中处理已存在 `user` 键迁移至 `userProfile`。
- 上线前调整监控告警阈值，确保异常及时捕获。

---

**审计完成时间**：2024年12月

**审计人员**：AI 助手

**下一步行动**：建议按优先级顺序修复 P0 和 P1 问题，并建立持续集成流程防止回归。


